{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": [
    "import { lintRule } from \"unified-lint-rule\";\nimport { visit } from \"unist-util-visit\";\nimport type { VFile } from \"vfile\";\nimport type { Node } from \"unist\";\n\ntype NonEmptyArray<T> = [T, ...T[]];\n\nexport type remarkLintWordCaseOptions = {\n  words: NonEmptyArray<string>;\n};\n\nexport enum remarkLintWordCaseError {\n  _OPTIONS_PREFIX = \"Invalid options:\",\n  OPTIONS_UNDEFINED = `${remarkLintWordCaseError._OPTIONS_PREFIX} options must include \\`words:\\` key.`,\n  OPTIONS_INVALID = `${remarkLintWordCaseError._OPTIONS_PREFIX} 'words' must be a non-empty array of strings.`,\n}\n\ninterface TextNode extends Node {\n  type: \"text\";\n  value: string;\n  position?: any;\n}\n\nfunction fixText(\n  text: string,\n  options: remarkLintWordCaseOptions,\n): string | undefined {\n  // check options at runtime\n  if (!options) {\n    throw new Error(remarkLintWordCaseError.OPTIONS_UNDEFINED);\n  }\n\n  if (\n    !Array.isArray(options.words) ||\n    options.words.length === 0 ||\n    options.words.some((word) => typeof word !== \"string\")\n  ) {\n    throw new Error(remarkLintWordCaseError.OPTIONS_INVALID);\n  }\n\n  const user_word_list = options.words;\n  const pattern = new RegExp(`\\\\b(${user_word_list.join(\"|\")})\\\\b`, \"gi\");\n\n  const matches = text.match(pattern);\n\n  let correctedText = text;\n\n  if (matches) {\n    let replacement: string | undefined;\n    matches.forEach((match) => {\n      replacement = user_word_list.find(\n        (word) => word.toLowerCase() === match.toLowerCase(),\n      );\n      if (replacement) {\n        correctedText = correctedText.replace(\n          new RegExp(`\\\\b${match}\\\\b`, \"g\"),\n          replacement,\n        );\n      }\n    });\n    return correctedText;\n  }\n  return;\n}\n\nfunction wordCaseRule(\n  tree: Node,\n  file: VFile,\n  options: remarkLintWordCaseOptions,\n) {\n  visit(tree, \"text\", (node: TextNode) => {\n    const correctedText = fixText(node.value, options);\n\n    if (!correctedText || correctedText === node.value) {\n      return;\n    }\n\n    const msg = file.message(\n      `Word case error. Expected \\`${correctedText.trim()}\\` found \\`${correctedText.trim()}\\``,\n      node,\n    );\n    msg.actual = node.value;\n    msg.expected = [correctedText];\n  });\n}\n\nconst remarkLintWordCase = lintRule(\"remark-lint:word-case\", wordCaseRule);\n\nexport default remarkLintWordCase;\n"
  ],
  "mappings": ";AAAA;AACA;AAUO,IAAK;AAAA,CAAL,CAAK,6BAAL;AAAA,EACL,8CAAkB;AAAA,EAClB,gDAAoB;AAAA,EACpB,8CAAkB;AAAA,GAHR;AAYZ,SAAS,OAAO,CACd,MACA,SACoB;AAAA,EAEpB,KAAK,SAAS;AAAA,IACZ,MAAM,IAAI,MAAM,6EAAyC;AAAA,EAC3D;AAAA,EAEA,KACG,MAAM,QAAQ,QAAQ,KAAK,KAC5B,QAAQ,MAAM,WAAW,KACzB,QAAQ,MAAM,KAAK,CAAC,SAAS,OAAO,SAAS,QAAQ,GACrD;AAAA,IACA,MAAM,IAAI,MAAM,sFAAuC;AAAA,EACzD;AAAA,EAEA,MAAM,iBAAiB,QAAQ;AAAA,EAC/B,MAAM,UAAU,IAAI,OAAO,OAAO,eAAe,KAAK,GAAG,SAAS,IAAI;AAAA,EAEtE,MAAM,UAAU,KAAK,MAAM,OAAO;AAAA,EAElC,IAAI,gBAAgB;AAAA,EAEpB,IAAI,SAAS;AAAA,IACX,IAAI;AAAA,IACJ,QAAQ,QAAQ,CAAC,UAAU;AAAA,MACzB,cAAc,eAAe,KAC3B,CAAC,SAAS,KAAK,YAAY,MAAM,MAAM,YAAY,CACrD;AAAA,MACA,IAAI,aAAa;AAAA,QACf,gBAAgB,cAAc,QAC5B,IAAI,OAAO,MAAM,YAAY,GAAG,GAChC,WACF;AAAA,MACF;AAAA,KACD;AAAA,IACD,OAAO;AAAA,EACT;AAAA,EACA;AAAA;AAGF,SAAS,YAAY,CACnB,MACA,MACA,SACA;AAAA,EACA,MAAM,MAAM,QAAQ,CAAC,SAAmB;AAAA,IACtC,MAAM,gBAAgB,QAAQ,KAAK,OAAO,OAAO;AAAA,IAEjD,KAAK,iBAAiB,kBAAkB,KAAK,OAAO;AAAA,MAClD;AAAA,IACF;AAAA,IAEA,MAAM,MAAM,KAAK,QACf,+BAA+B,cAAc,KAAK,eAAe,cAAc,KAAK,OACpF,IACF;AAAA,IACA,IAAI,SAAS,KAAK;AAAA,IAClB,IAAI,WAAW,CAAC,aAAa;AAAA,GAC9B;AAAA;AAGH,IAAM,qBAAqB,SAAS,yBAAyB,YAAY;AAEzE,IAAe;",
  "debugId": "795A60F76A4B76D964756E2164756E21",
  "names": []
}