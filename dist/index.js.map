{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": [
    "import { lintRule } from \"unified-lint-rule\";\nimport { visit } from \"unist-util-visit\";\nimport { VFile } from \"vfile\";\nimport type { Literal, Node, Position } from \"unist\";\nimport type { VFileMessage } from \"vfile-message\";\nimport { location } from \"vfile-location\";\n\ntype NonEmptyArray<T> = [T, ...T[]];\n\nexport type remarkLintWordCaseOptions = {\n  words: NonEmptyArray<string>;\n};\n\nexport enum remarkLintWordCaseError {\n  _OPTIONS_PREFIX = \"Invalid options:\",\n  OPTIONS_UNDEFINED = `${remarkLintWordCaseError._OPTIONS_PREFIX} options must include \\`words:\\` key.`,\n  OPTIONS_INVALID = `${remarkLintWordCaseError._OPTIONS_PREFIX} 'words' must be a non-empty array of strings.`,\n}\n\ninterface TextNode extends Literal {\n  type: \"text\";\n  value: string;\n  // A TextNode has a position if it's generated from a source file\n  position?: Position;\n}\n\n// This result now includes the index within the node's value string\ntype LintResult = {\n  expected: string;\n  actual: string;\n  index: number; // The starting index of the 'actual' word within the node's text\n};\n\n/**\n * Lints a single text node and returns a result for each incorrect word found.\n */\nfunction lintText(\n  node: TextNode,\n  options: remarkLintWordCaseOptions,\n): LintResult[] {\n  const results: LintResult[] = [];\n  const { words } = options;\n  const pattern = new RegExp(`\\\\b(${words.join(\"|\")})\\\\b`, \"gi\");\n\n  let match;\n  // Use `exec` in a loop to get the index of each match\n  while ((match = pattern.exec(node.value)) !== null) {\n    const actual = match[0]; // The matched word (e.g., \"javascript\")\n\n    // Find the correctly-cased version from the user's list\n    const expected = words.find(\n      (word) => word.toLowerCase() === actual.toLowerCase(),\n    );\n\n    // Only report an error if the casing is actually wrong\n    if (expected && expected !== actual) {\n      results.push({\n        expected,\n        actual,\n        index: match.index, // The starting position of the match in `node.value`\n      });\n    }\n  }\n\n  return results;\n}\n\n/**\n * The main linting rule function.\n */\nfunction wordCaseRule(\n  tree: Node,\n  file: VFile,\n  options: remarkLintWordCaseOptions,\n) {\n  // --- Option validation ---\n  if (!options) {\n    throw new Error(remarkLintWordCaseError.OPTIONS_UNDEFINED);\n  }\n  if (\n    !Array.isArray(options.words) ||\n    options.words.length === 0 ||\n    options.words.some((word) => typeof word !== \"string\")\n  ) {\n    throw new Error(remarkLintWordCaseError.OPTIONS_INVALID);\n  }\n  // --- End validation ---\n\n  const loc = location(file); // Create a location service for the file\n\n  visit(tree, \"text\", (node: TextNode) => {\n    // A node might not have a position if it was created programmatically\n    if (!node.position || !node.position.start.offset) {\n      return;\n    }\n    const nodeStartOffset = node.position.start.offset;\n\n    const results = lintText(node, options);\n\n    // For each incorrect word found, calculate its precise position and create a message\n    results.forEach((res) => {\n      // Calculate the word's absolute start and end offsets in the file\n      const wordStartOffset = nodeStartOffset + res.index;\n      const wordEndOffset = wordStartOffset + res.actual.length;\n\n      // Convert offsets to {line, column} points\n      const start = loc.toPoint(wordStartOffset);\n      const end = loc.toPoint(wordEndOffset);\n\n      if (!start || !end) {\n        throw new Error(\"undefined start or end point\");\n      }\n\n      const wordPosition: Position = {\n        start: start,\n        end: end,\n      };\n\n      const msg: VFileMessage = file.message(\n        `Incorrect word case. Expected \\`${res.expected}\\` but found \\`${res.actual}\\``,\n        wordPosition, // Use the calculated position of the specific word\n      );\n\n      msg.expected = [res.expected];\n      msg.actual = res.actual;\n      msg.source = \"remark-lint-word-case\"; // Good practice to name your rule\n      msg.ruleId = \"word-case\";\n    });\n  });\n}\n\nconst remarkLintWordCase = lintRule(\"remark-lint:word-case\", wordCaseRule);\n\nexport default remarkLintWordCase;\n"
  ],
  "mappings": ";AAAA;AACA;AAIA;AAQO,IAAK;AAAA,CAAL,CAAK,6BAAL;AAAA,EACL,8CAAkB;AAAA,EAClB,gDAAoB;AAAA,EACpB,8CAAkB;AAAA,GAHR;AAuBZ,SAAS,QAAQ,CACf,MACA,SACc;AAAA,EACd,MAAM,UAAwB,CAAC;AAAA,EAC/B,QAAQ,UAAU;AAAA,EAClB,MAAM,UAAU,IAAI,OAAO,OAAO,MAAM,KAAK,GAAG,SAAS,IAAI;AAAA,EAE7D,IAAI;AAAA,EAEJ,QAAQ,QAAQ,QAAQ,KAAK,KAAK,KAAK,OAAO,MAAM;AAAA,IAClD,MAAM,SAAS,MAAM;AAAA,IAGrB,MAAM,WAAW,MAAM,KACrB,CAAC,SAAS,KAAK,YAAY,MAAM,OAAO,YAAY,CACtD;AAAA,IAGA,IAAI,YAAY,aAAa,QAAQ;AAAA,MACnC,QAAQ,KAAK;AAAA,QACX;AAAA,QACA;AAAA,QACA,OAAO,MAAM;AAAA,MACf,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,OAAO;AAAA;AAMT,SAAS,YAAY,CACnB,MACA,MACA,SACA;AAAA,EAEA,KAAK,SAAS;AAAA,IACZ,MAAM,IAAI,MAAM,6EAAyC;AAAA,EAC3D;AAAA,EACA,KACG,MAAM,QAAQ,QAAQ,KAAK,KAC5B,QAAQ,MAAM,WAAW,KACzB,QAAQ,MAAM,KAAK,CAAC,SAAS,OAAO,SAAS,QAAQ,GACrD;AAAA,IACA,MAAM,IAAI,MAAM,sFAAuC;AAAA,EACzD;AAAA,EAGA,MAAM,MAAM,SAAS,IAAI;AAAA,EAEzB,MAAM,MAAM,QAAQ,CAAC,SAAmB;AAAA,IAEtC,KAAK,KAAK,aAAa,KAAK,SAAS,MAAM,QAAQ;AAAA,MACjD;AAAA,IACF;AAAA,IACA,MAAM,kBAAkB,KAAK,SAAS,MAAM;AAAA,IAE5C,MAAM,UAAU,SAAS,MAAM,OAAO;AAAA,IAGtC,QAAQ,QAAQ,CAAC,QAAQ;AAAA,MAEvB,MAAM,kBAAkB,kBAAkB,IAAI;AAAA,MAC9C,MAAM,gBAAgB,kBAAkB,IAAI,OAAO;AAAA,MAGnD,MAAM,QAAQ,IAAI,QAAQ,eAAe;AAAA,MACzC,MAAM,MAAM,IAAI,QAAQ,aAAa;AAAA,MAErC,KAAK,UAAU,KAAK;AAAA,QAClB,MAAM,IAAI,MAAM,8BAA8B;AAAA,MAChD;AAAA,MAEA,MAAM,eAAyB;AAAA,QAC7B;AAAA,QACA;AAAA,MACF;AAAA,MAEA,MAAM,MAAoB,KAAK,QAC7B,mCAAmC,IAAI,0BAA0B,IAAI,YACrE,YACF;AAAA,MAEA,IAAI,WAAW,CAAC,IAAI,QAAQ;AAAA,MAC5B,IAAI,SAAS,IAAI;AAAA,MACjB,IAAI,SAAS;AAAA,MACb,IAAI,SAAS;AAAA,KACd;AAAA,GACF;AAAA;AAGH,IAAM,qBAAqB,SAAS,yBAAyB,YAAY;AAEzE,IAAe;",
  "debugId": "5EC409693B1B5FA064756E2164756E21",
  "names": []
}